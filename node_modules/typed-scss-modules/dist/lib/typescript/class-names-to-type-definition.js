"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var reserved_words_1 = __importDefault(require("reserved-words"));
var core_1 = require("../core");
exports.EXPORT_TYPES = ["named", "default"];
exports.QUOTE_TYPES = ["single", "double"];
exports.exportTypeDefault = "named";
exports.exportTypeNameDefault = "ClassNames";
exports.exportTypeInterfaceDefault = "Styles";
exports.quoteTypeDefault = "single";
var classNameToNamedTypeDefinition = function (className) {
    return "export const " + className + ": string;";
};
var classNameToInterfaceKey = function (className, quoteType) {
    var quote = quoteType === "single" ? "'" : '"';
    return "  " + quote + className + quote + ": string;";
};
var isReservedKeyword = function (className) {
    return reserved_words_1.default.check(className, "es5", true) ||
        reserved_words_1.default.check(className, "es6", true);
};
var isValidName = function (className) {
    if (isReservedKeyword(className)) {
        core_1.alerts.warn("[SKIPPING] '" + className + "' is a reserved keyword (consider renaming or using --exportType default).");
        return false;
    }
    else if (/-/.test(className)) {
        core_1.alerts.warn("[SKIPPING] '" + className + "' contains dashes (consider using 'camelCase' or 'dashes' for --nameFormat or using --exportType default).");
        return false;
    }
    return true;
};
exports.classNamesToTypeDefinitions = function (options) {
    if (options.classNames.length) {
        var typeDefinitions = void 0;
        var _a = options.exportTypeName, ClassNames = _a === void 0 ? exports.exportTypeNameDefault : _a, _b = options.exportTypeInterface, Styles = _b === void 0 ? exports.exportTypeInterfaceDefault : _b;
        switch (options.exportType) {
            case "default":
                typeDefinitions = "export interface " + Styles + " {\n";
                typeDefinitions += options.classNames
                    .map(function (className) {
                    return classNameToInterfaceKey(className, options.quoteType || exports.quoteTypeDefault);
                })
                    .join("\n");
                typeDefinitions += "\n}\n\n";
                typeDefinitions += "export type " + ClassNames + " = keyof " + Styles + ";\n\n";
                typeDefinitions += "declare const styles: " + Styles + ";\n\n";
                typeDefinitions += "export default styles;\n";
                return typeDefinitions;
            case "named":
                typeDefinitions = options.classNames
                    .filter(isValidName)
                    .map(classNameToNamedTypeDefinition);
                // Sepearte all type definitions be a newline with a trailing newline.
                return typeDefinitions.join("\n") + "\n";
            default:
                return null;
        }
    }
    else {
        return null;
    }
};
